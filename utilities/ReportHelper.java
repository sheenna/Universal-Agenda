package utilities;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.Arrays;
import java.util.Collections;

/**
 * The ReportHelper class handles all the report generation for the program.
 */
public class ReportHelper {

    /**
     * generateReport generates a report based on the report name designated in the combobox of the Report Tab.
     * The report is generated by querying the database and appending the results to a string.
     * The string is then returned to the Report Tab to be displayed in the text area.
     * I very much wanted to play with formatting the report in a text area, but it proved to be difficult without the use of Java.Swing.
     * However, I used while loops to run through the results and StringBuilders to append the results to the report string.
     * I very much enjoyed how this came out.
     *
     * The last report in particular was difficult to format, and ended up only coming out in reverse.
     * Incredibly frustrating, but I used a Collections.reverse() method to reverse the list and get the results in the correct order.
     *
     *
     * <p>
     *     This method uses a switch statement to determine which report to generate.
     *     Monthly Appointment Summaries and Contact Schedules correspond with the first two Report requirements,
     *     and User Geography corresponds with the custom report requirement.
     * </p>
     *
     * I've also made a note of arrow expressions that are not lambda expressions, they simply use the arrow expression syntax.
     * Lambda expressions are commented on elsewhere.
     *
     * @param reportName the report name
     * @return the string
     * @throws SQLException the sql exception
     * @see "Switch-cases"
     */
    public static String generateReport(String reportName) throws SQLException {
        String report = "Not created yet, sorry.";

        switch (reportName) {
            case "Monthly Appointment Summaries" -> { //NOT LAMBDA
                String query;

                query = "SELECT MONTHNAME(start) AS Month, Type, COUNT(*) AS \"Total\" " +
                        "FROM client_schedule.appointments " +
                        "GROUP BY Month, Type " +
                        "ORDER BY Month, Type";


                ResultSet rs = DatabaseHelper.executeQuery(query);
                StringBuilder sb = new StringBuilder();

                // Add title
                sb.append("\n").append("MONTHLY APPOINTMENT SUMMARIES\n").append("_______________________________________\n").append("\n");

                // Append column headers
                sb.append(String.format("%-10s %-20s %s%n", "Month", "Type", "Total\n"));

                // Append table data
                while (rs.next()) {
                    String month = rs.getString("Month");
                    String type = rs.getString("Type");
                    int total = rs.getInt("Total");
                    sb.append(String.format("%-10s %-20s %s%n", month, type, total));

                }

                report = sb.toString();

                return report;


            }
            case "Contact Schedules" -> { //NOT LAMBDA
                String query;

                query = "SELECT c.Contact_ID, c.Contact_Name, a.Appointment_ID, a.Title, a.Type, a.Description, a.Start, a.End, a.Customer_ID " +
                        "FROM client_schedule.contacts c " +
                        "JOIN client_schedule.appointments a ON c.Contact_ID = a.Contact_ID " +
                        "ORDER BY c.Contact_ID, a.Start";


                StringBuilder sb = new StringBuilder();

                sb.append("\n").append("CONTACT SCHEDULES\n").append("_______________________________________").append("\n");

                ResultSet rs = DatabaseHelper.executeQuery(query);

                String contactName = "";
                int contactID = -1;
                int appointmentID = -2;

                while (rs.next()) {
                    String newContactName = rs.getString("Contact_Name");
                    int newContactID = rs.getInt("Contact_ID");

                    // Append contact name and ID if different from previous row
                    if (!newContactName.equalsIgnoreCase(contactName) || newContactID != contactID) {
                        contactName = newContactName.toUpperCase();
                        contactID = newContactID;
                        sb.append("\n").append(contactName.toUpperCase()).append("\n").append("Contact ID: ").append(contactID).append("\n");
                    }

                    String title = rs.getString("Title");
                    String description = rs.getString("Description");
                    String startTime = String.valueOf(rs.getTimestamp("Start"));
                    String endTime = String.valueOf(rs.getTimestamp("End"));
                    int customerID = rs.getInt("Customer_ID");

                    // Append appointment details
                    sb.append("Appointment ID: ").append(rs.getInt("Appointment_ID")).append("\n");
                    sb.append(title).append("\n").append(description).append("\n");
                    sb.append("Start Time: ").append(startTime).append("\n");
                    sb.append("End Time: ").append(endTime).append("\n");
                    sb.append("Customer ID: ").append(customerID).append("\n\n");
                }

                report = sb.toString();

                return report;

            }
            case "Customer Geography" -> { //NOT LAMBDA


                String query = "SELECT COUNT(c.Customer_ID) AS Total_Customers, co.Country, d.Division " +
                        "FROM client_schedule.first_level_divisions d " +
                        "LEFT JOIN client_schedule.customers c ON c.Division_ID = d.Division_ID " +
                        "JOIN client_schedule.countries co ON d.Country_ID = co.Country_ID " +
                        "GROUP BY co.Country, d.Division " +
                        "HAVING COUNT(c.Customer_ID) > 0 OR COUNT(c.Customer_ID) IS NULL " +
                        "ORDER BY co.Country, d.Division";

                // Execute the SQL query and get the resultset
                ResultSet rs = DatabaseHelper.executeQuery(query);

                // Initialize variables for tracking the current country and total customers
                String currentCountry = "";
                int currentCountryTotal = 0;

                // Create a StringBuilder to hold the formatted resultset
                StringBuilder sb = new StringBuilder();

                // Loop through the resultset
                while (rs.next()) {
                    String country = rs.getString("Country");
                    String division = rs.getString("Division");
                    int total = rs.getInt("Total_Customers");

                    // If this is a new country, add the previous country's total to the StringBuilder and reset the total
                    if (!country.equals(currentCountry)) {
                        if (!currentCountry.isEmpty()) {
                            sb.append(currentCountry).append(" (").append(currentCountryTotal).append(")\n");
                        }
                        currentCountry = country;
                        currentCountryTotal = 0;
                    }

                    // If the division has customers, add it to the StringBuilder and update the total
                    if (total > 0) {
                        sb.append("\t").append(division).append(" (").append(total).append(")\n");
                    }

                    currentCountryTotal += total;
                }

                // Add the last country's total to the StringBuilder
                sb.append(currentCountry).append(" (").append(currentCountryTotal).append(")\n");

                sb.append("\n").append("_______________________________________\n").append("CUSTOMER GEOGRAPHY\n");

                sb.append(System.lineSeparator());

                // Return the formatted resultset
                // Reverse the order of lines in the report
                report = sb.toString();
                String[] lines = report.split("\n");
                Collections.reverse(Arrays.asList(lines));
                report = String.join("\n", lines);

                return report;
            }
        }
        return "";
    }
}
